<?php
// $Id$

/**
 * @file
 * Install, update, and uninstall functions for the organic groups module.
 */

/**
 * Implement hook_enable().
 *
 * Add group audience to users by default. This can't be in hook_install() as
 * the field isn't known yet.
 */
function group_enable() {
  group_create_field('group_audience', 'user', 'user');

  // Set default roles and permissions.
  group_set_global_access();
}


/**
 * Implement hook_uninstall().
 */
function group_uninstall() {
  $vars = array(
    'group_context',
    'group_group_manager_full_access',
    'group_skip_access',
  );
  foreach ($vars as $var) {
    variable_del($var);
  }
}


/**
 * Implement hook_schema().
 */
function group_schema() {
  $schema = array();

  $schema['group_groups'] = array(
    'description'     => 'Store information related to the groups.',
    'fields'          => array(
      'gid' => array(
        'description' => "The group's unique ID.",
        'type' => 'serial',
        'unsigned' => TRUE,
        'not null' => TRUE,
      ),
      'etid' => array(
        'description' => "The entity ID.",
        'type' => 'int',
        'unsigned' => TRUE,
        'not null' => TRUE,
        'default' => 0,
      ),
      'entity_type' => array(
        'description' => "The entity type (e.g. node, comment, etc').",
        'type' => 'varchar',
        'length' => '32',
        'not null' => TRUE,
        'default' => '',
      ),
      'state' => array(
        'description' => 'The state of the group (i.e. active or disabled).',
        'type' => 'int',
        'not null' => TRUE,
        'default' => 1,
      ),
	    'created' => array(
	      'description' => 'The Unix timestamp when the group was created.',
	      'type' => 'int',
	      'not null' => TRUE,
	      'default' => 0,
	    ),
    ),
    'primary key' => array('gid'),
  );

  $schema['group_role_permission'] = array(
    'description' => 'Stores the permissions assigned to user roles per group.',
    'fields' => array(
      'rid' => array(
        'type' => 'int',
        'unsigned' => TRUE,
        'not null' => TRUE,
        'description' => 'Foreign Key: {role}.rid.',
      ),
      'permission' => array(
        'type' => 'varchar',
        'length' => 64,
        'not null' => TRUE,
        'default' => '',
        'description' => 'A single permission granted to the role identified by rid.',
      ),
      'module' => array(
        'type' => 'varchar',
        'length' => 255,
        'not null' => TRUE,
        'default' => '',
        'description' => "The module declaring the permission.",
      ),
    ),
    'primary key' => array('rid', 'permission'),
    'indexes' => array(
      'permission' => array('permission'),
    ),
    'foreign keys' => array(
      'rid' => array('role' => 'rid'),
    ),
  );

  $schema['group_role'] = array(
    'description' => 'Stores user roles per group.',
    'fields' => array(
      'rid' => array(
        'type' => 'serial',
        'unsigned' => TRUE,
        'not null' => TRUE,
        'description' => 'Primary Key: Unique role ID.',
      ),
      'gid'               => array(
        'description'     => "The group's unique ID.",
        'type'            => 'int',
        'size'            => 'normal',
        'not null'        => TRUE,
      ),
      'name' => array(
        'type' => 'varchar',
        'length' => 64,
        'not null' => TRUE,
        'default' => '',
        'description' => 'Unique role name per group.',
      ),
    ),
    'primary key' => array('rid'),
  );

  $schema['group_users_roles'] = array(
    'description' => 'Maps users to roles.',
    'fields' => array(
      'uid' => array(
        'type' => 'int',
        'unsigned' => TRUE,
        'not null' => TRUE,
        'default' => 0,
        'description' => 'Primary Key: {users}.uid for user.',
      ),
      'rid' => array(
        'type' => 'int',
        'unsigned' => TRUE,
        'not null' => TRUE,
        'default' => 0,
        'description' => 'Primary Key: {group_role}.rid for role.',
      ),
      'gid'               => array(
        'description'     => "The group's unique ID.",
        'type'            => 'int',
        'size'            => 'normal',
        'not null'        => TRUE,
      ),
    ),
    'primary key' => array('uid', 'rid'),
    'indexes' => array(
      'rid' => array('rid'),
    ),
    'foreign keys' => array(
      'uid' => array('users' => 'uid'),
      'rid' => array('group_role' => 'rid'),
    ),
  );

  return $schema;
}

if (module_exists('group')) {
  /**
   * Implements hook_update_N()
   *
   * Upgrade path from Organic groups for Drupal 6 to Group for Drupal 7:
   * - Add group fields to nodes.
   * - Move Organic groups' data into the fields of group.
   * - Delete Organic groups' variables.
   */
  function group_update_7000(&$context) {
    $context['#finished'] = 0;

    $content_type = array('group' => array(), 'group content' => array());

    // If this is the first time this functions is called in the batch process,
    // create fields for the content types.
    if (!isset($context['total'])) {

      foreach (node_type_get_types() as $type) {
        // check if the variable exists.
        if ($type_usage = variable_get('og_content_type_usage_' . $type->type)) {
          switch ($type_usage) {
            case 'group':
              $content_type['group'][] = $type->type;
              break;

            case 'group_post_standard':
            case 'group_post_wiki':
              $content_type['group content'][] = $type->type;
              break;

          }
        }
      }

      if ($content_type) {
        // Add group and group content fields to content types.
        $fields = array(
          'group' => GROUP_GROUP_FIELD,
          'group content' => GROUP_AUDIENCE_FIELD,
        );
        foreach ($fields as $key => $field_name) {
          foreach ($content_type[$key] as $type) {
            group_create_field($field_name, 'node', $type);
          }
        }
      }

      // Initialize state for future calls.
      $context['last'] = 0;
      $context['count'] = 0;

      // Hold the information about the callbacks that upgrade the different
      // fields.
      $context['group upgrade'] = array('group', 'group_content', 'user');

      $query = db_select('og', 'og');
      $group_total = $query->countQuery()->execute()->fetchField();

      $query = db_select('og_ancestry', 'oga');
      $group_content_total = $query->countQuery()->execute()->fetchField();

      $query = db_select('og_uid', 'ogu');
      $group_user_total = $query->countQuery()->execute()->fetchField();

      $context += array(
        'group_total' => $group_total,
        'group_content_total' => $group_content_total,
        'group_user_total' => $group_user_total,
      );

        // Sum of all groups to be converted.
      $context['total'] = $group_total + $group_content_total + $group_user_total;
    }
    else {
      if ($context['total']) {
        $callback = reset($context['group upgrade']);
        $found = call_user_func('_group_upgrade_' . $callback, $context);

        if (!$found) {
          // Continue to the next upgrade element.
          array_shift($context['group upgrade']);
        }

        $context['#finished'] = min(0.99, $context['count'] / $context['total']);
      }
    }
    if (empty($context['group upgrade'])) {
      // All nodes are processed.

      // We're done.
      $context['#finished'] = 1;
      return t("!number groups and group content converted to use new Group fields.", array('!number' => $context['total']));
    }
  }
}

function _group_upgrade_group(&$context) {
  $found = FALSE;

  // Operate on every revision of every node, in batches.
  $batch_size = 200;
  $query = db_select('node_revision', 'nr');
  $query->innerJoin('node', 'n', 'n.vid = nr.vid');
  $query->innerJoin('og_ancestry', 'oga', 'n.nid = oga.nid');
  $query
    ->fields('nr', array('nid', 'vid'))
    ->fields('n', array('type', 'created'))
    ->condition('nr.vid', $context['last'], '>')
    ->orderBy('nr.vid', 'ASC')
    ->range(0, $batch_size);
  $revisions = $query->execute();

  // Holds the node IDs with their earliest revision and timestamp, to create a
  // group entity.
  $nids = array();
  foreach ($revisions as $revision) {
    $found = TRUE;

    $node = (object) array(
      'nid' => $revision->nid,
      'vid' => $revision->vid,
      'type' => $revision->type,
    );

    if (empty($nids[$revision->nid]) || $nids[$revision->nid] > $revision->created) {
      $nids[$revision->nid] = $revision->created;
    }

    // Set field values.
    $property = GROUP_GROUP_FIELD;
    $node->{$property}[LANGUAGE_NONE][0]['value'] = TRUE;

    field_attach_update('node', $node);

    $context['last'] = $revision->vid;
    $context['count'] += 1;
  }

  if ($nids) {
    foreach ($nids as $nid => $created) {
      // Create a new group if doesn't exist.
      $group = group_get_group('node', $nid, TRUE);
      if (!empty($group->is_new)) {
        $group->created = $created;
        group_save($group);
      }
    }
  }

  return $found;

}