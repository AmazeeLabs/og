<?php
// $Id$

/**
 * @file
 * Enable users to create and manage groups.
 */

// Load all Field module hooks for organic groups.
require(drupal_get_path('module', 'og') . '/og.field.inc');

// site admin chooses in og_settings() whether group creator can put his group on the registration form
define('OG_REGISTRATION_NEVER', 0);
define('OG_REGISTRATION_ALWAYS', 1);
define('OG_REGISTRATION_CHOOSE_TRUE', 2);
define('OG_REGISTRATION_CHOOSE_FALSE', 3);

// site admin chooses in og_settings() whether group creator can put his group in the Groups directory
define('OG_DIRECTORY_NEVER', 0);
define('OG_DIRECTORY_ALWAYS', 1);
define('OG_DIRECTORY_CHOOSE_TRUE', 2);
define('OG_DIRECTORY_CHOOSE_FALSE', 3);

// Dispositioning of content and memberships after deletion of a group node.
define('OG_DELETE_NOTHING', 0);
define('OG_DELETE_ORPHANS', 1);
define('OG_DELETE_MOVE_NODES', 2);
define('OG_DELETE_MOVE_NODES_MEMBERSHIPS', 3);

/**
 * Define active group post states.
 */
define('OG_STATE_ACTIVE', 'active');

/**
 * Define pending group post states. The user is subscribed to the group but
 * isn't an active member yet.
 */
define('OG_STATE_PENDING', 'pending');

/**
 * Define blocked group post states. The user is rejected from the group.
 */
define('OG_STATE_BLOCKED', 'blocked');


/**
 * Modules should return this value from hook_og_access() to allow access to a
 * group menu item.
 */
define('OG_ACCESS_ALLOW', 'allow');

/**
 * Modules should return this value from hook_og_access() to deny access to a
 * group menu item.
 */
define('OG_ACCESS_DENY', 'deny');

/**
 * Modules should return this value from hook_og_access() to not affect group
 * menu item access.
 */
define('OG_ACCESS_IGNORE', NULL);

/**
 * Group audience field.
 */
define('OG_AUDIENCE_FIELD', 'og_audience');

/**
 * The role name of group non-members.
 */
define('OG_ANONYMOUS_ROLE', 'anonymous member');

/**
 * The role name of group member.
 */
define('OG_AUTHENTICATED_ROLE', 'authenticated member');

/**
 * The role name of group administrator.
 */
define('OG_ADMINISTRATOR_ROLE', 'administrator');

/*******************************************************************************
 * Hook implementations
 ******************************************************************************/

/**
 * Implement hook_menu().
 */
function og_menu() {
  $items['og/%node/subscribe'] = array(
    'type' => MENU_CALLBACK,
    'file' => 'og.pages.inc',
    'page callback' => 'og_subscribe',
    'page arguments' => array(1),
    'access callback' => 'og_access',
    'access arguments' => array('subscribe', 1),
    // We don't add the group name, as it might be private.
    'title' => 'Join group'
  );

  $items['og/opml'] = array(
    'type' => MENU_CALLBACK,
    'page callback' => 'og_opml',
    'access callback' => 'user_is_logged_in',
    'title' => 'OPML',
  );

  $items['og/%node/unsubscribe'] = array(
    'type' => MENU_CALLBACK,
    'file' => 'og.pages.inc',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('og_confirm_unsubscribe', 1),
    'access callback' => 'og_access',
    'access arguments' => array('unsubscribe', 1),
    'title' => 'Leave group',
  );

  $items['og/%node/approve/%user/%'] = array(
    'type' => MENU_CALLBACK,
    'page callback' => 'og_approve',
    'page arguments' => array(1, 3, 4),
    'access callback' => 'og_access',
    'access arguments' => array('approve membership', 1, 3),
    'title' => 'Approve membership request',
    'file' => 'og.pages.inc',
  );
  $items['og/%node/deny/%user/%'] = array(
    'type' => MENU_CALLBACK,
    'page callback' => 'og_deny',
    'page arguments' => array(1, 3, 4),
    'access callback' => 'og_access',
    'access arguments' => array('deny membership', 1, 3, 4),
    'title' => 'Deny membership request',
  );

  $items['og/%node/invite'] = array(
    'page callback' => 'drupal_get_form',
    'page arguments' => array('og_invite_form', 1),
    'access callback' => 'og_access',
    'access arguments' => array('invite', 1),
    'title' => 'Send invitation',
    'type' => MENU_CALLBACK,
    'file' => 'og.pages.inc',
  );
  $items["og/%node/manage"] = array(
    'page callback' => 'og_manage',
    'page arguments' => array(1),
    'access callback' => 'og_access',
    'access arguments' => array('manage', 1),
    'title' => 'Manage membership',
    'type' => MENU_CALLBACK,
    'file' => 'og.pages.inc',
  );

  // User listing pages.
  $items['og/%node/admin/people'] = array(
    'title arguments' => array('People in group @group', 1),
    'title callback' => 'og_menu_title_callback',
    'description' => 'Find and manage group members.',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('og_user_admin_account', 1),
    'access callback' => 'og_access',
    'access arguments' => array('administer group users', 1),
    'weight' => -4,
    'file' => 'og.admin.inc',
  );

  // Permission administration pages.
  $items['og/%node/admin/people/roles'] = array(
    'title arguments' => array('Roles for group @group', 1),
    'title callback' => 'og_menu_title_callback',
    'description' => 'List, edit, or add user roles.',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('og_user_admin_new_role', 1),
    'access callback' => 'og_access',
    'access arguments' => array('administer permissions'),
    'file' => 'og.admin.inc',
    'weight' => -9,
  );

  $items['og/%node/admin/people/roles/edit'] = array(
    'title' => 'Edit role',
    'page arguments' => array('og_user_admin_role', 1),
    'access callback' => 'og_access',
    'access arguments' => array('administer permissions'),
    'type' => MENU_CALLBACK,
  );

  $items['og/%node/admin/people/permissions'] = array(
    'title arguments' => array('Permissions for group @group', 1),
    'title callback' => 'og_menu_title_callback',
    'description' => 'Determine access to features by selecting permissions for roles.',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('og_user_admin_permissions', 1),
    'access callback' => 'og_access',
    'access arguments' => array('administer permissions'),
    'file' => 'og.admin.inc',
    'weight' => -8,
  );

  $items['node/%node/og'] = array(
    'title' => 'Organic groups',
    'page callback' => 'og_group_admin_overview',
    'page arguments' => array(1),
    'access callback' => 'og_organic_groups_tab_access',
    'access arguments' => array(1),
    'type' => MENU_LOCAL_TASK,
    'file' => 'og.admin.inc',
  );

  $items['admin/og'] = array(
    'title' => 'Organic groups',
    'description' => 'Administer the suite of Organic groups modules.',
    'position' => 'right',
    'weight' => -5,
    'page callback' => 'system_admin_menu_block_page',
    'access arguments' => array('administer site configuration'),
    'file' => 'system.admin.inc',
    'file path' => drupal_get_path('module', 'system'),
  );
  $items['admin/og/og'] = array(
    'page callback' => 'drupal_get_form',
    'page arguments' => array('og_admin_settings'),
    'title' => 'Organic groups configuration',
    'access arguments' => array('administer site configuration'),
    'description' => 'Configure organic groups module.',
    'file' => 'og.admin.inc',
    'file path' => drupal_get_path('module', 'og'),
    'weight' => -5,
  );

  $items['og/%node/add-user'] = array(
    'page callback' => 'drupal_get_form',
    'title' => 'Add members',
    'page arguments' => array('og_add_users', 1),
    'type' => MENU_LOCAL_TASK,
    'file' => 'og.pages.inc',
    'weight' => 5,
    'access callback' => 'og_access',
    'access arguments' => array('add user', 1),
  );

  return $items;
}

/**
 * Return TRUE if a node is a group node and the user has administrator rights.
 */
function og_organic_groups_tab_access($node) {
  return og_is_group_type($node->type) && og_user_access($node->nid, 'administer group users');
}

/**
 * Implement hook_init().
 */
function og_init() {
  if ($group_node = og_determine_context()) {
    og_set_context($group_node);
  }
}

/**
 * Implement hook_theme().
 */
function og_theme() {
  return array(
    'og_user_admin_permissions' => array(
      'arguments' => array('form' => NULL),
      'file' => 'og.admin.inc',
    ),
    'og_user_admin_new_role' => array(
      'arguments' => array('form' => NULL),
      'file' => 'og.admin.inc',
    ),
    'og_user_admin_account' => array(
      'arguments' => array('form' => NULL),
      'file' => 'og.admin.inc',
    ),
  );
}

/**
 * Implement hook_forms().
 */
function og_forms() {
  $forms['og_user_admin_new_role']['callback'] = 'og_user_admin_role';
  return $forms;
}

/**
 * Implement hook_form_FORM_ID_alter().
 */
function og_form_node_type_form_alter(&$form, &$form_state) {
  $node_type = $form['#node_type']->type;

 // Get all the group usage types options.
  $options = array();
  foreach (og_get_og_types() as $key => $value) {
    $options[$value['type']][$key] = check_plain($value['description']);
  }

  $form['og'] = array(
    '#type' => 'fieldset',
    '#title' => t('Organic groups'),
    '#collapsible' => TRUE,
    '#group' => 'additional_settings',
    '#description' => t('Specify how organic groups should treat content of this type. Content may behave as a group, as group posts, or may not participate in organic groups at all.'),
  );

  $form['og']['og_group_type'] = array(
    '#type' => 'radios',
    '#title' => t('Group'),
    '#default_value' =>  og_is_group_type($node_type) ? og_get_group_type($node_type, 'group') : 'omitted',
    '#options' => array('omitted' => t('Not a group type')) + $options['group'],
  );

  $form['og']['og_group_post_type'] = array(
    '#type' => 'radios',
    '#title' => t('Group post'),
    '#default_value' =>  og_is_group_post_type($node_type) ? og_get_group_type($node_type, 'group post') : 'omitted',
    '#options' => array('omitted' => t('Not a group post type')) + $options['group post'],
  );

  // Add own submit handler.
  $form['#submit'][] = 'og_node_type_form_submit';
}

/**
 * Submit handler; Set the group type.
 *
 * We can't use hook_node_type_insert() to set the group, since variables are
 * saved later on.
 * @see node_type_form_submit().
 */
function og_node_type_form_submit($form, &$form_state) {
  $type = $form_state['values']['type'];
  $og_types = og_get_og_types();
  $og_type = $og_types[$form_state['values']['og_group_post_type']]['type'];

  if ($og_type == 'group post') {
    og_group_post_type_set_fields(array($type));
  }
}

/**
* Implement hook_node_type_delete().
*/
function og_node_type_delete($info) {
  variable_del('og_group_type_' . $info->type);
  variable_del('og_group_post_type_' . $info->type);
}

/**
* Implement hook_node_type_insert().
*
* TODO: USe after http://drupal.org/node/586436 gets in.
*/
function og_node_type_insert($info) {
}

/**
* Implement hook_node_insert().
*/
function og_node_insert($node) {
  if (og_is_group_type($node->type)) {
    // Add group.
    og_set_group($node->nid);
    // Subscribe the node author to the group.
    $account = user_load($node->uid);

    og_subscribe_user(array(array('value' => $node->nid, 'state' => OG_STATE_ACTIVE)), $account);

    // Create default roles.
    $role = new stdClass;
    $role->name = OG_ANONYMOUS_ROLE;
    $role->nid = $node->nid;
    og_user_role_save($role);
    $anon_rid = $role->rid;

    unset($role->rid);
    $role->name = OG_AUTHENTICATED_ROLE;
    og_user_role_save($role);
    $auth_rid = $role->rid;

    unset($role->rid);
    $role->name = 'admin';
    og_user_role_save($role);
    $admin_rid = $role->rid;

    // Create default permissions for roles.
    $perms = array(
      OG_ANONYMOUS_ROLE => array('subscribe', 'view group', 'view group posts'),
      OG_AUTHENTICATED_ROLE => array('subscribe', 'unsubscribe', 'view group', 'view group posts'),
      // All permissions.
      OG_ADMINISTRATOR_ROLE => array_keys(og_permissions_get()),
    );

    // Allow other modules to change default permissions.
    drupal_alter('og_group_insert', $perms, $node);

    og_user_role_grant_permissions($anon_rid, $perms[OG_ANONYMOUS_ROLE]);
    og_user_role_grant_permissions($auth_rid, $perms[OG_AUTHENTICATED_ROLE]);
    og_user_role_grant_permissions($admin_rid, $perms[OG_ADMINISTRATOR_ROLE]);
  }
}


/**
* Implement hook_node_update().
*
* In most cases group will be already registered on og_node_insert() however if
* the content already exists, but wasn't defined as a group node, then we must
* make sure it is registered.
*/
function og_node_update($node) {
  if (og_is_group_type($node->type) && !og_get_group($node->nid)) {
    og_node_insert($node);
  }
}

/**
* Implement hook_node_delete().
*/
function og_node_delete($node) {
  if (og_is_group_type($node->type)) {
    // Remove group.
    og_delete_group($node->nid);
  }
}

/**
* Implement hook_node_view().
*/
function og_node_view($node, $build_mode) {
  if (og_is_group_type($node->type) && og_user_access($node->nid, 'subscribe')) {
    // Check user association with the group.
    $links = array();
    global $user;
    if ($group = og_get_group_from_object($node->nid, 'user', $user)) {
      // check the user state.
      if ($group['state'] == OG_STATE_PENDING) {
        $links['og_subscribe']['title'] = t('Re-request group membership');
        $links['og_subscribe']['href'] = "og/$node->nid/subscribe";
      }
      elseif ($group['state'] == OG_STATE_ACTIVE && $node->uid != $user->uid) {
        $links['og_subscribe']['title'] = t('Unsubscribe from group');
        $links['og_subscribe']['href'] = "og/$node->nid/unsubscribe";
      }
    }
    else {
      if (og_user_access($node->nid, 'subscribe without approval')) {
        $links['og_subscribe']['title'] = t('Subscribe to group');
      }
      else {
        $links['og_subscribe']['title'] = t('Request group membership');
      }
      $links['og_subscribe']['href'] = "og/$node->nid/subscribe";
    }

    if ($links) {
      $node->content['links']['og'] = array(
        '#theme' => 'links',
        '#links' => $links,
        '#attributes' => array('class' => array('links', 'inline')),
      );
    }
  }
}


/**
 * Implement og_permission
 */
function og_og_permission() {
  return array(
    'subscribe' => array(
      'title' => t('Subscribe user to group'),
      'description' => t("Allow user to be a member of a group (approval required)."),
    ),
    'subscribe without approval' => array(
      'title' => t('Subscribe user to group (no approval required).'),
      'description' => t("Allow user to be a member of a group without an approval of the group administrator."),
    ),
    'unsubscribe' => array(
      'title' => t('Unsubscribe user from group'),
      'description' => t("Allow user to be remove membership from a group."),
    ),
    'approve and deny subscription' => array(
      'title' => t('Approve and deny subscription'),
      'description' => t("Allow user to allow or deny another user's subscription request."),
    ),
    'add user' => array(
      'title' => t('Add user'),
      'description' => t("Add a new user to the group."),
    ),
    'administer group users' => array(
      'title' => t('Administer group users'),
      'description' => t('Manage or block users, and manage their role assignments in the group.'),
    ),
    'view group' => array(
      'title' => t('View group'),
      'description' => t('View the group content.'),
    ),
    'update group' => array(
      'title' => t('Edit group'),
      'description' => t('Edit the group content.'),
    ),
    'view group posts' => array(
      'title' => t('View group posts'),
      'description' => t('View the group posts that belong to the group.'),
    ),
    'update own group posts' => array(
      'title' => t('Edit own group posts'),
      'description' => t('Edit own group posts that belong to the group.'),
    ),
    'update any group posts' => array(
      'title' => t('Edit any group posts'),
      'description' => t('Edit any group posts that belong to the group.'),
    ),
    'delete own group posts' => array(
      'title' => t('Delete own group posts'),
      'description' => t('Delete own group posts that belong to the group.'),
    ),
    'delete any group posts' => array(
      'title' => t('Delete any group posts'),
      'description' => t('Delete any of the group posts that belong to the group.'),
    ),
  );
}

/**
 * Implement hook_og_access().
 */
function og_og_access($op, $node, $acting_user, $account) {
  if (og_is_group_type($node->type)) {
    if (og_user_access($node->nid, $op, $acting_user)) {
      return OG_ACCESS_ALLOW;
    }
  }
  return OG_ACCESS_IGNORE;
}

/**
 * Implement hook_og_node_access()
 */
function og_og_node_access($node, $op, $account) {
  if (og_is_group_type($node->type)) {
    if (og_user_access($node->nid, $op . ' group', $account)) {
      return NODE_ACCESS_ALLOW;
    }
  }
  else {
    // We don't have a context, so we need to get all the permissions
    // of all the groups. We don't intersect with the user's group, as
    // groups might allow anonymous members access.
    $gids = array_keys(og_get_groups('node', $node));
    foreach ($gids as $gid) {
      if (og_user_access($gid, $op . ' group posts', $account) || og_user_access($gid, $op . ' any group posts', $account) || (og_user_access($gid, $op . ' own group posts', $account) && $node->uid == $account->uid)) {
        return NODE_ACCESS_ALLOW;
      }
    }
  }
}

/**
 * Implement hook_node_access()
 */
function og_node_access($node, $op, $account) {
  $type = is_string($node) ? $node : (is_array($node) ? $node['type'] : $node->type);
  if ($op != 'create' && (og_is_group_type($type) || og_is_group_post_type($type))) {
    $access = module_invoke_all('og_node_access', $node, $op, $account);
    if (in_array(OG_ACCESS_DENY, $access, TRUE)) {
      return NODE_ACCESS_DENY;
    }
    elseif (in_array(OG_ACCESS_ALLOW, $access, TRUE)) {
      return NODE_ACCESS_ALLOW;
    }

    // We didn't get any allow access so in the organic groups realm, we decide
    // to deny access.
    return NODE_ACCESS_DENY;
  }
  // Not an organic group node type.
  return NODE_ACCESS_IGNORE;
}

/**
 * Implement hook_element_info().
 *
 * Define a group selection form element.
 *
 * Keyes definition:
 * - read_only: Determine if the form element should allow a user input, or only
 *   show the group audience.
 * - opt_group: If TRUE then the group lists will be consisted of "my groups"
 *   and "other groups". This is set automatically to TRUE, by the processing
 *   function, for administrator users.
 * - opt_group_access_check: If TRUE then the opt_group will be determined
 *   automatically, otherwise, it will use the opt_group value.
 * - user_groups: Array with the group the user is subscribed to keyed by the
 *   group node ID and the group node title.
 * - user_groups: Array with the group the user is not subscribed to keyed by
 *   the group node ID and the group node title.
 * - exclude: Array with the group node IDs that should be excluded from the
 *   list.
 * - minimum_for_select_list: The number of groups in the "user_groups" array
 *   that should be the minimum for showing a select list instead of checkboxes
 *   or radios.
 * - uid: The user ID. This can be used in order to created a form element for
 *   a different user than the acting user.
 */
function og_element_info() {
  return array(
    'og_audience' => array(
      '#read_only' => FALSE,
      '#opt_group' => FALSE,
      '#opt_group_access_check' => TRUE,
      '#user_groups' => array(),
      '#other_groups' => array(),
      '#exclude' => array(),
      '#minimum_for_select_list' => 20,
      '#uid' => NULL,
      '#process' => array('og_elements_process'),
    ),
  );
}

/**
 * Implement hook_og_types_info().
 */
function og_og_types_info() {
  return array(
    'group' => array(
       'type' => 'group',
       'description' => t('Group node'),

     ),
     'group post' => array(
       'type' => 'group post',
       'description' => t('Standard group post (typically only author may edit).'),
     ),
  );
}


/*******************************************************************************
 * API functions
 ******************************************************************************/

/**
 * Get a group object.
 *
 * The group object is not the group node. It is the data related to a group,
 * which can be for example the access permissions per group.
 *
 * @param $nid
 *   The group node ID.
 */
function og_get_group($nid) {
  $group = &drupal_static(__FUNCTION__, array());

  if (empty($group[$nid])) {
    $result = db_query("SELECT * FROM {og_groups} WHERE nid = :nid", array(':nid' => $nid))->fetchObject();
    // Unserialize the data.
    $result->data = unserialize($result->data);

    // Allow other modules to change the group object.
    drupal_alter('og_get_group', $result);

    $group[$nid] = $result;
  }

  return $group[$nid];
}

/**
 * Set a group object.
 *
 * @param $nid
 *   The group node ID.
 * @param $data
 *   Optional; An array with data related to the group.
 */
function og_set_group($nid, $data = array()) {
  $group = new stdClass();
  $group->nid = $nid;
  $group->data = $data;

  // Allow other modules to change the group object.
  drupal_alter('og_set_group', $group);

  // Delete an existing record.
  og_delete_group($nid);

  // Write the new record.
  drupal_write_record('og_groups', $group);
}

/**
 * Delete a group object.
 *
 * @param $nid
 *   The group node ID.
 */
function og_delete_group($nid) {
  db_delete('og_groups')
    ->condition('nid', $nid)
    ->execute();
}

/**
 * Get all the users belonging to a group.
 *
 * @param $nid
 *   The group node ID.
 * @param $count
 * @param $cursor
 *
 * @return
 *   Array keyed with the object IDs and the value as array with the field
 *   values.
 */
function og_get_group_users($nid, $states = array(OG_STATE_ACTIVE), $count = FIELD_QUERY_NO_LIMIT, &$cursor = 0) {
  $return = array();

  $field = field_info_field('og_audience');

  $conditions = array(
    array('value', $nid),
    array('type', 'user'),
  );

  // Get the objects IDs.
  if ($result = field_attach_query($field['id'], $conditions, $count, $cursor)) {
    $uids = array();
    foreach ($result['user'] as $key => $value) {
      $uids[$key] = $key;
    }

    // Load the users.
    $accounts = user_load_multiple($uids);

    // Prepare the return values.
    foreach ($accounts as $account) {
      $group = (object)og_get_group_from_object($nid, 'user', $account);

      // Check if the user's state is valid.
      if (!empty($states) && !in_array($group->state, $states)) {
        continue;
      }
      // OG audience may be multiple field, but the group can appear only once,
      // so we extract only the value with our requested group.
      $return[$account->uid] = $group;
      // Add back the user ID and user name.
      $return[$account->uid]->uid = $account->uid;
      $return[$account->uid]->name = $account->name;
    }
  }
  return $return;
}

/**
 * Extract a specific group from an object.
 *
 * @param $object
 *   The object.
 * @param $nid
 *   The group node ID.
 * @return
 *   Array with the field's value.
 */
function og_get_group_from_object($nid, $obj_type, $object, &$key = NULL) {
  $object = og_load_object($obj_type, $object);
  if (!empty($object->{OG_AUDIENCE_FIELD}[FIELD_LANGUAGE_NONE])) {
    foreach ($object->{OG_AUDIENCE_FIELD}[FIELD_LANGUAGE_NONE] as $key_index => $value) {
      if ($value['value'] == $nid) {
        // Save the position of the value in the field.
        $key = $key_index;
        return $value;
      }
    }
  }
}

/**
 * Get the groups a content is associated with.
 *
 * @param $obj_type
 *   The object type (e.g. "node" or "user").
 * @param $object
 *   The object can be a user, node or any fieldable entity.
 * @param $state
 *   Optioanl; Array with the state to return. If empty all state will return.
 * @return
 *  An array with the group, or an empty array.
 */
function og_get_groups($obj_type, $object, $state = array(OG_STATE_ACTIVE)) {
  // Load object to get the fields.
  $object = og_load_object($obj_type, $object);

  $groups = array();
  if (!empty($object->{OG_AUDIENCE_FIELD}[FIELD_LANGUAGE_NONE])) {
    foreach ($object->{OG_AUDIENCE_FIELD}[FIELD_LANGUAGE_NONE] as $group) {
      if (!empty($state) && !in_array($group['state'], $state)) {
        // Don't register the group if it's state isn't the one we look for.
        continue;
      }
      $groups[$group['value']] = $group['value'];
    }
  }
  return $groups;
}

/**
 * Get an array with all the types of group or group posts available.
 */
function og_get_og_types() {
  $og_types = &drupal_static(__FUNCTION__, array());

  if (!empty($og_types)) {
    return $og_types;
  }

  $og_types = module_invoke_all('og_types_info');
  // Add a non organic groups type.
  $og_types['omitted'] = array('type' => 'omitted', 'description' => t('May not be posted into a group.'));

  return $og_types;
}

/**
 * Return all content types which meet a specified organic group type.
 *
 * @param $type
 * Optional; An array with the organic group types, for example "group" or
 * "group_post".
 * @return
 * An array keyed with content type and organic group type as value, or all
 * the content types if $type is empty.
 */
function og_get_node_type_by_og_type($og_types = array()) {
  $return = array();
  if (empty($og_types)) {
    // All organic groups types.
    $og_types = array_keys(og_get_og_types());
  }
  foreach (node_type_get_types() as $type => $value) {
     $usage = og_get_group_type($type);
    if (in_array($usage, $og_types)) {
      $return[$type] = $usage;
    }
  }
  return $return;
}

/**
 * Return the group type (i.e. "group" or "group_post") of a node type.
 *
 * @param $node_type
 *   The node type to be checked.
 * @param $type
 *   The grou usage type. Must be "group" or "group post".
 *
 * @return
 *   The group type or an "omitted" if node type doesn't participate in
 *   organic groups.
 */
function og_get_group_type($node_type, $type = 'group') {
  if ($type == 'group') {
    return variable_get('og_group_type_' . $node_type, 'omitted');
  }
  elseif ($type == 'group post') {
    return variable_get('og_group_post_type_' . $node_type, 'omitted');
  }

}

/**
 * Return TRUE if the node type is a "group" type.
 *
 * This is a wrapper function around og_get_group_type().
 *
 * @param $node_type
 *   The node type to be checked.
 */
function og_is_group_type($node_type) {
  return og_get_group_type($node_type, 'group') != 'omitted';
}

/**
 * Return TRUE if the node type is a "group post" type.
 *
 * This is a wrapper function around og_get_group_type().
 *
 * @param $node_type
 *   The node type to be checked.
 */
function og_is_group_post_type($node_type) {
  return og_get_group_type($node_type, 'group post') != 'omitted';
}

/**
 * Subscribe a user to groups.
 *
 * @param $groups
 *   Array of the groups to subscribe the user.
 * @param $account
 *   Optional; A user object.
 * @param $replace
 *   Optioanl; True if the group lists should replace the existing subscrptions
 *   of the user.
 * @param $request
 *   Optioanl; A message created by the requesting user that should be sent to
 *   the group admins.
 */
function og_subscribe_user($groups = array(), $account = NULL, $replace = FALSE, $request = '') {
  if (empty($account)) {
    global $user;
    $account = $user;
  }
  og_set_association('user', $account, $groups, $replace, $request);
}

/**
 * Unsubscribe a user from groups.
 *
 * @param $gids
 *   Array of the groups to unsubscribe the user.
 * @param $account
 *   Optional; A user object.
 */
function og_unsubscribe_user($gids = array(), $account = NULL) {
  if (empty($account)) {
    global $user;
    $account = $user;
  }

  og_delete_association('user', $account, $gids);

  // Delete any roles the user had.
  foreach ($gids as $gid) {
    foreach ( og_get_user_roles($gid, $account->uid) as $rid) {
      og_users_roles_revoke($gid, $account->uid, $rid);
    }
  }
}

/**
 * Set an association (e.g. subscribe) an object to a group.
 *
 * @param $obj_type
 *   The object type (e.g. "node" or "user").
 * @param $object
 *   The object to set the association.
 * @param $groups
 *   Keyed array of the groups to subscribe the object. Keys are:
 *   "value" - The group ID.
 *   "state" - Optioanl; The state of the association.
 *   "data" - Optioanl; Array with data related to the association.
 * @param $replace
 *   Optioanl; True if the group lists should replace the existing subscrptions
 *   of the user.
 * @param $request
 *   Optioanl; A message created by the requesting user that should be sent to
 *   the group admins.
 */
function og_set_association($obj_type, $object, $groups = array(), $replace = FALSE, $request = '') {
  // Load object to get the fields.
  $object = og_load_object($obj_type, $object);

  $op = empty($object->og_audience) ? 'insert' : 'update';
  if ($replace) {
    unset($object->og_audience);
  }

  // Will be used later to keep only groups that are not yet associated with the
  // group.
  $existing_gids = og_get_groups($obj_type, $object, array());

  // Allow other modules to change the subscribed groups.
  drupal_alter('og_set_association', $groups, $obj_type, $object);

  // Indicate if the object was changed, and needs to be saved.
  $save = FALSE;

  foreach ($groups as $group) {
    $key = 0;
    if ($value = og_get_group_from_object($group['value'], $obj_type, $object, $key)) {
      // Group already exists, so we will replace it. The key was return from
      // og_get_group_from_object().
      // We preserve the data and state values, provided they aren't changed.
      $group = array_merge($value, $group);
      $object->og_audience[FIELD_LANGUAGE_NONE][$key] = $group;
      $save = TRUE;
    }
    else {
      // Initialize values.
      $group += array('state' => '', 'data' => array());
      // Add a new record.
      $object->og_audience[FIELD_LANGUAGE_NONE][] = $group;
      $save = TRUE;
    }
  }

  if ($save) {
    og_invoke_event();
    call_user_func('field_attach_' . $op, $obj_type, $object);
  }
}

/**
 * Set an association (e.g. subscribe) an object to a group.
 *
 * @param $obj_type
 *   The object type (e.g. "node" or "user").
 * @param $object
 *   The object to set the association.
 * @param $groups
 *   Array with the group IDs to delete.
 */
function og_delete_association($obj_type, $object, $gids = array()) {
  // Load object to get the fields.
  $object = og_load_object($obj_type, $object);

  // Indicate if the object was changed, and needs to be saved.
  $save = FALSE;

  foreach ($object->og_audience[FIELD_LANGUAGE_NONE] as $key => $group) {
    if (in_array($group['value'], $gids)) {
      unset($object->og_audience[FIELD_LANGUAGE_NONE][$key]);

      og_invoke_event();
      $save = TRUE;
    }
  }

  if ($save) {
    call_user_func('field_attach_update', $obj_type, $object);
  }
}


/**
 * Menu callback; Central access point for all organic groups actions.
 *
 * Function is imittating hook_node_access().
 *
 * @param $op
 *   The operation name.
 * @param $node
 *   Optioanl; The node object.
 * @param $account
 *   Optioanl; The user related to the action. For example if the operation is
 *   "subscribe" then the account will be the subscribing user.
 * @param $acting_user
 *   Optioanl; The acting user. For example if the operation is
 *   "subscribe" then the acting user might be the admin who should approve
 *   or deny - according to this user access is decided.
 *   If this field is empty the current user is used.
 * @return
 *   TRUE if access is allowed, otherise FALSE.
 */
function og_access($op, $node = NULL, $account = NULL, $acting_user = NULL) {
  if (empty($acting_user)) {
    global $user;
    $acting_user = $user;
  }
  if (user_access('administer organic groups', $acting_user)) {
    return TRUE;
  }

  if ($node->uid == $acting_user->uid) {
    // Group manager.
    return TRUE;
  }

  $acting_user = og_load_object('user', $acting_user);
  if (!empty($account)) {
    $account = og_load_object('user', $account);
  }

  // Check if the user was blocked.
  if (($value = og_get_group_from_object($node->nid, 'user', $acting_user)) && $value['state'] == OG_STATE_BLOCKED) {
    return FALSE;
  }

  $access = module_invoke_all('og_access', $op, $node, $acting_user, $account);
  if (in_array(OG_ACCESS_DENY, $access, TRUE)) {
    return FALSE;
  }
  elseif (in_array(OG_ACCESS_ALLOW, $access, TRUE)) {
    return TRUE;
  }
  // No one allowed access, so assume access is denied.
  return FALSE;
}

/**
 * Set group context using the menu system.
 *
 * Modules may override the custom theme and group context set here.
 * @see og_set_group_context()
 *
 * @return
 *   A group node object, or NULL if no context was found.
 */
function og_determine_context() {
  $item = menu_get_item();
  $object = menu_get_object();

  // Use the menu system to get the path.
  $path = $item['path'];

  // Check if this is an existing node.
  if (!empty($object->nid)) {
    $node = $object;
  }
  // Check if we are in the node add page.
  elseif (strpos($path, 'node/add') === 0 && !empty($_REQUEST['gids'])) {
    // URL pattern: node/add/story?gids[]=1
    $gid = intval(current($_REQUEST['gids']));
    $node = node_load($gid);
  }
  elseif (!empty($item['map']) && ($item['map'][0] == 'og' && !empty($item['map'][2])) || $path == 'comment/reply/%') {
    $node = menu_get_object('node', 2);
  }
  elseif ($path == 'comment/edit' || $path == 'comment/delete') {
    // Get the node from the comment object.
    $comment = comment_load($item['page_arguments'][0]);
    $node = node_load($comment->nid);
  }

  if (!empty($node) && ($group_node = og_determine_context_by_node($node))) {
    return $group_node;
  }
}

/**
 * Get an appropriate group node to be set as the group context.
 *
 * If a group post belongs to multiple group nodes, the logic for determining the
 * group node is:
 * 1) TODO: Are we still writing things to the session ?
 *    The group we showed on the prior page view (if any).
 * 2) The only or one of the group(s) the current user is a member of.
 * 3) The 'first' group in $node->og_groups.
 *
 * @param $node
 *   The node that the context should be retrieved from.
 * @param $account
 *   (optional) The account to check, if not given use currently logged in user.
 * @return
 *   The group node if exists and accessible by the user.
 *
 * @see og_determine_context()
 */
function og_determine_context_by_node($node, $account = NULL) {
  if (empty($account)) {
    global $user;
    $account = $user;
  }
  if (og_is_group_type($node->type)) {
    $group_node = $node;
  }
  elseif (og_is_group_post_type($node->type) && ($groups = og_get_groups('node', $node))) {

    if ($user_groups = og_get_groups('user', $account)) {
      $gid = current(array_intersect(array_keys($groups), array_keys($user_groups)));
    }

    if (!empty($group)) {
      $group_node = node_load($group);
    }
  }
  // Make sure user has view access to the group node.
  if (!empty($group_node) && node_access('view', $group_node, $account)) {
    return $group_node;
  }
}

/**
 * Get the group context, if exists, for the current request.
 *
 * This is Used for things like setting current theme and breadcrumbs.
 * The context is set during og_determine_context().
 *
 * @return
 *   The group node ID if exists.
 */
function og_get_context() {
  return og_set_context();
}

/**
 * Set the group context for the current request.
 *
 * Modules may set this as needed.
 * This context is originally set during hook_init().
 *
 * @param $node
 *   The group node object that should be set as the context.
 * @param $determine
 *   If set to TRUE, then try to determine the context using the menu system.
 * @return
 *   The group node ID if set.
 */
function og_set_context($node = NULL, $determine = FALSE) {
  $gid = &drupal_static(__FUNCTION__, '');

  if ($gid) {
    return $gid;
  }

  if ($determine) {
    $node = og_determine_context();
  }

  if (!empty($node) && og_is_group_type($node->type)) {
    $gid = $node->nid;
  }

  return $gid;
}

/*******************************************************************************
 * Function callbacks
 ******************************************************************************/

/**
 * Menu callback; Return the title of a menu item based on the group title.
 */
function og_menu_title_callback($title, $node) {
  return str_replace('@group', check_plain($node->title), $title);
}

/**
 * Process organic groups audience FAPI element.
 */
function og_elements_process($element, &$form_state, $form) {
  $field = $form['#fields'][$element['#field_name']]['field'];
  $instance = $form['#fields'][$element['#field_name']]['instance'];
  $field_key  = $element['#columns'][0];

  // Allow showing the form element for another user.
  if (!empty($element['uid'])) {
    $account = user_load($element['uid']);
  }
  else {
   global $user;
    $account = $user;
  }
  $content_groups = og_allowed_values($field, $account);

  // Determine if a user may see other groups as-well.
  $opt_group = FALSE;

  if (user_access('administer organic groups')) {
    $opt_group = TRUE;
  }
  elseif ($element['#opt_group'] && $element['#opt_group_access_check']) {
    $opt_group = TRUE;
  }
  // The group options presented to the user.
  $options = array();
  $element['#exclude'] = drupal_map_assoc($element['#exclude']);
  if ($opt_group) {
    // Show "My groups" and "Other groups".
    $groups_count = count($content_groups['content groups']) + count($content_groups['other groups']);
    if (!empty($content_groups['content groups'])) {
      $options += array(t('My groups') => array_diff_key($content_groups['content groups'], $element['#exclude']));
    }
    if (!empty($content_groups['other groups'])) {
      $options += array(t('Other groups') => array_diff_key($content_groups['other groups'], $element['#exclude']));
    }
    $type = 'select';
  }
  else {
    // Show only "My groups".
    $groups_count = count($content_groups['content groups']);
    $options = array_diff_key($content_groups['content groups'], $element['#exclude']);
    // Show a select list if their are a minimum of groups.
    if ($field['cardinality'] == 1) {
      $type = 'radios';
    }
    else {
      $type = $groups_count >= $element['#minimum_for_select_list'] ? 'select' : 'checkboxes';
    }
  }

  $element[$field_key] = array(
    '#type' => $type,
    '#title' => !empty($element['#title']) ? $element['#title'] : t('Group audience'),
    '#description' => !empty($groups_count) ? t('Select the groups this content should be associated with.') : t('There are no groups you can select from.'),
    '#options' => $options,
    '#default_value' => $element['#default_value'],
    '#required' => isset($element['#required']) ? $element['#required'] : $instance['required'],
    '#multiple' => isset($element['#multiple']) ? $element['#multiple'] : $field['cardinality'] > 1 || $field['cardinality'] == FIELD_CARDINALITY_UNLIMITED,
    '#attributes' => !empty($element['#attributes']) ? $element['#attributes'] : array('class' => array('og-audience')),
    '#disabled' => empty($groups_count),
  );

  // Set #element_validate in a way that it will not wipe out other
  // validation functions already set by other modules.
  if (empty($element['#element_validate'])) {
    $element['#element_validate'] = array();
  }
  array_unshift($element['#element_validate'], 'options_validate');

  // Make sure field info will be available to the validator which
  // does not get the values in $form.
  $form_state['#fields'][$element['#field_name']] = $form['#fields'][$element['#field_name']];

  return $element;
}

/**
 * Create an array of allowed values for OG audience field.
 *
 * @return
 *   Array keyed by "content groups" and "other groups".
 */
function og_allowed_values($field, $account = NULL) {
  $allowed_values = &drupal_static(__FUNCTION__, array());

  if (isset($allowed_values[$field['field_name']])) {
    return $allowed_values[$field['field_name']];
  }

  if (empty($account)) {
    global $user;

    $account = $user;
  }
  $allowed_values[$field['field_name']] = og_get_groups_for_form('user', $account);
  return $allowed_values[$field['field_name']];
}

/**
 * Get the groups a content belongs to - ready to be used in a form element.
 *
 * @param $obj_type
 *   The object type (e.g. "node" or "user").
 * @param $object
 *   The object can be a user, node or any fieldable entity.
 * @return
 *   An array keyed by "content groups" and "other groups". Inside them there are
 *   the group's node ID and the sanitized group's name.
 *
 * @see og_get_groups_of_content().
 */
function og_get_groups_for_form($obj_type, $object) {
  $return = array('content groups' => array(), 'other groups' => array());
  // Get all the existing groups.
  if ($all_groups = og_get_all_groups_for_form()) {

    // Get the groups belonging to the content.
    $content_groups = og_get_groups($obj_type, $object);

    // TODO: Is it faster to use array_diff & array_intersect?
    foreach ($all_groups as $nid => $name) {
      if (in_array($nid, $content_groups)) {
        $return['content groups'][$nid] = $name;
      }
      else {
        $return['other groups'][$nid] = $name;
      }
    }
  }

  return $return;
}

function og_get_all_groups_for_form() {
  $return = db_query("SELECT og.nid, n.title FROM {og_groups} og INNER JOIN {node} n ON og.nid = n.nid ORDER BY og.nid")->fetchAllKeyed();
  // Sanitize the result.
  array_walk($return, 'check_plain');
  return $return;
}

/**
 * Wrapper function to invoke a Rules event.
 */
function og_invoke_event() {
  if (module_exists('rules')) {
    // Invoke a rule event.
  }
}

/**
 * Return a re-loaded object with its fields.
 *
 * This is needed only if a user account is passed, as global $user is only a
 * partial user object.
 * @param $obj_type
 *   The object type.
 * @param $object
 *   The object.
 */
function og_load_object($obj_type, $object) {
  if ($obj_type == 'user') {
    $object = user_load($object->uid);
  }
  return $object;
}


/********************* Role/ Permissions API *************************/

/**
 * Determine the permissions for one or more roles.
 *
 * @param $roles
 *   An array whose keys are the role IDs of interest, such as $user->roles.
 *
 * @return
 *   An array indexed by role ID. Each value is an array whose keys are the
 *   permission strings for the given role ID.
 */
function og_user_role_permissions($roles = array()) {
  $cache = &drupal_static(__FUNCTION__, array());

  $role_permissions = $fetch = array();

  if ($roles) {
    foreach ($roles as $rid => $name) {
      if (isset($cache[$rid])) {
        $role_permissions[$rid] = $cache[$rid];
      }
      else {
        // Add this rid to the list of those needing to be fetched.
        $fetch[] = $rid;
        // Prepare in case no permissions are returned.
        $cache[$rid] = array();
      }
    }

    if ($fetch) {
      // Get from the database permissions that were not in the static variable.
      // Only role IDs with at least one permission assigned will return rows.
      $result = db_query("SELECT rid, permission FROM {og_role_permission} WHERE rid IN (:fetch)", array(':fetch' => $fetch));

      foreach ($result as $row) {
        $cache[$row->rid][$row->permission] = TRUE;
      }
      foreach ($fetch as $rid) {
        // For every rid, we know we at least assigned an empty array.
        $role_permissions[$rid] = $cache[$rid];
      }
    }
  }

  return $role_permissions;
}

/**
 * Determine whether the user has a given privilege.
 *
 * @param $nid
 *   The group node ID.
 * @param $string
 *   The permission, such as "administer nodes", being checked for.
 * @param $account
 *   (optional) The account to check, if not given use currently logged in user.
 *
 * @return
 *   Boolean TRUE if the current user has the requested permission.
 *
 * All permission checks in OG should go through this function. This
 * way, we guarantee consistent behavior, and ensure that the superuser
 * can perform all actions.
 */
function og_user_access($nid, $string, $account = NULL) {
  global $user;
  $perm = &drupal_static(__FUNCTION__, array());

  if (!isset($account)) {
    $account = $user;
  }

  // User #1 has all privileges.
  if ($account->uid == 1) {
    return TRUE;
  }

  // Group member has all privileges.
  $group = node_load($nid);
  if ($group->uid == $account->uid) {
    return TRUE;
  }

  // To reduce the number of SQL queries, we cache the user's permissions
  // in a static variable, if the user is authenticated.
  if (!isset($perm[$nid][$account->uid])) {
    $user_groups = og_get_groups('user', $account);

    // Get default roles.
    $default_roles = og_get_group_default_roles($nid);
    if (!in_array($nid, $user_groups)) {
      // Keep only the anonymous role.
      $roles = drupal_map_assoc(array($default_roles[OG_ANONYMOUS_ROLE]));
    }
    else {
      // Add the authenticated role.
      $roles = drupal_map_assoc(array($default_roles[OG_AUTHENTICATED_ROLE]));
      // Get otehr roles assigned to the user in the group.
      $roles += og_get_user_roles($nid, $account->uid);
    }

    $role_permissions = og_user_role_permissions($roles);
    $perms = array();
    foreach ($role_permissions as $one_role) {
      $perms += $one_role;

      $perm[$nid][$account->uid] = $perms;
    }
  }
  return isset($perm[$nid][$account->uid][$string]);
}


/**
 * Retrieve an array of roles matching specified conditions.
 *
 * @param $membersonly
 *   Set this to TRUE to exclude the 'anonymous' role.
 * @param $permission
 *   A string containing a permission. If set, only roles containing that
 *   permission are returned.
 *
 * @return
 *   An associative array with the role id as the key and the role name as
 *   value. The anonymous and authenticated deault roles are on the top of the
 *   array.
 */
function og_user_roles($nid, $roles = array(), $membersonly = FALSE, $permission = NULL) {
  if (!empty($permission)) {
    $roles = db_query("SELECT r.rid, r.name FROM {og_role} r INNER JOIN {og_role_permission} p ON r.rid = p.rid WHERE p.permission = :permission AND r.nid = :nid ORDER BY r.name", array(':permission' => $permission, ':nid' => $nid))->fetchAllKeyed();
  }
  else {
    $roles = db_query("SELECT rid, name FROM {og_role} WHERE nid = :nid ORDER BY name = :anon AND name = :auth AND name", array(':nid' => $nid, ':anon' => OG_ANONYMOUS_ROLE, ':auth' => OG_AUTHENTICATED_ROLE))->fetchAllKeyed();
  }

  // Filter to remove unmatched system roles.
  return  array_filter($roles);
}

/**
 * Get the anonymous and authenticated user roles ID of a group.
 *
 * @param $nid
 *   The group ID.
 * @return
 *   A keyed array with "anonymous" and "authenticaed".
 */
function og_get_group_default_roles($nid) {
  return db_query("SELECT name, rid FROM {og_role} WHERE nid = :nid AND (name = :anon OR name = :auth)", array(':nid' => $nid, ':anon' => OG_ANONYMOUS_ROLE, ':auth' => OG_AUTHENTICATED_ROLE))->fetchAllKeyed();
}

/**
 * Get all roles ID of a group.
 *
 * @param $nid
 *   The group ID.
 * @return
 *   An array keyed with the role name and the role ID as the value.
 */
function og_get_group_roles($nid) {
  return db_query("SELECT name, rid FROM {og_role} WHERE nid = :nid", array(':nid' => $nid))->fetchAllKeyed();
}

/**
 * Get all roles ID of a user in a certain group.
 *
 * @param $nid
 *   The group ID.
 * @param $uid
 *   The user ID.
 * @return
 *   Array with the role IDs of the user.
 */
function og_get_user_roles($nid, $uid) {
  return db_query("SELECT rid, rid FROM {og_users_roles} WHERE uid = :uid AND nid = :nid", array(':uid' => $uid, ':nid' => $nid))->fetchAllKeyed();
}

/**
 * Get all the users with certain roles in a group.
 *
 * @param $nid
 *   The group node ID.
 * @param $roles
 *   Array with the roles to query.
 */
function og_get_users_by_roles($nid, $roles = array()) {
  $query = db_select('og_users_roles', 'og_users_roles');
  return $query->fields('og_users_roles', array('uid'))
    ->condition('nid', $nid)
    ->condition('role', $roles, 'IN')
    ->execute()
    ->fetchAll();
}


/**
 * Fetch a user role from database.
 *
 * @param $rid
 *   An integer with the role ID.
 * @return
 *   A fully-loaded role object if a role with the given name or ID
 *   exists, FALSE otherwise.
 */
function og_user_role_load($rid) {
  $result = db_query("SELECT * FROM {og_role} WHERE rid = :rid", array(':rid' => $rid));
  return $result->fetchObject();
}
/**
 * Save a user role to the database.
 *
 * @param $role
 *   A role object to modify or add. If $role->rid is not specified, a new
 *   role will be created.
 * @return
 *   Status constant indicating if role was created or updated.
 *   Failure to write the user role record will return FALSE. Otherwise.
 *   SAVED_NEW or SAVED_UPDATED is returned depending on the operation
 *   performed.
 */
function og_user_role_save($role) {
  if ($role->name) {
    // Prevent leading and trailing spaces in role names.
    $role->name = trim($role->name);
  }
  if (!empty($role->rid) && $role->name) {
    $status = drupal_write_record('og_role', $role, 'rid');
    module_invoke_all('og_user_role_update', $role);
  }
  else {
    $status = drupal_write_record('og_role', $role);
    module_invoke_all('og_user_role_insert', $role);
  }

  // Clear the user access cache.
  drupal_static_reset('og_user_access');
  drupal_static_reset('og_user_role_permissions');

  return $status;
}

/**
 * Delete a user role from database.
 *
 * @param $role
 *   A string with the role name, or an integer with the role ID.
 */
function og_user_role_delete($rid) {
  $role = og_user_role_load($rid);

  db_delete('og_role')
    ->condition('rid', $rid)
    ->execute();
  db_delete('og_role_permission')
    ->condition('rid', $rid)
    ->execute();
  // Update the users who have this role set:
  db_delete('og_users_roles')
    ->condition('rid', $rid)
    ->execute();

  module_invoke_all('og_user_role_delete', $role);

  // Clear the user access cache.
  drupal_static_reset('og_user_access');
  drupal_static_reset('og_user_role_permissions');
}

/**
 * Grant a group role to a user.
 *
 * @param $uid
 *   The user ID.
 * @param $rid
 *   The role ID.
 */
function og_users_roles_grant($nid, $uid, $rid) {
  // Get the existiong user roles.
  $user_roles = og_get_user_roles($nid, $uid);
  if (!in_array($rid, $user_roles)) {
    $role = new stdClass();
    $role->uid = $uid;
    $role->rid = $rid;
    $role->nid = $nid;

    drupal_write_record('og_users_roles', $role);
    og_invoke_event();
    module_invoke_all('og_users_roles_grant', $nid, $uid, $rid);
  }
}

/**
 * Revoke a group role from a user.
 *
 * @param $uid
 *   The user ID.
 * @param $rid
 *   The role ID.
 */
function og_users_roles_revoke($nid, $uid, $rid) {
  // Get the existiong user roles.
  $user_roles = og_get_user_roles($nid, $uid);
  if (in_array($rid, $user_roles)) {

    db_delete('og_users_roles')
      ->condition('uid', $uid)
      ->condition('rid', $rid)
      ->execute();
    module_invoke_all('og_users_roles_revoke', $nid, $uid, $rid);
  }

}

/**
 * Change permissions for a user role.
 *
 * This function may be used to grant and revoke multiple permissions at once.
 * For example, when a form exposes checkboxes to configure permissions for a
 * role, the submitted values may be directly passed on in a form submit
 * handler.
 *
 * @param $rid
 *   The ID of a user role to alter.
 * @param $permissions
 *   An array of permissions, where the key holds the permission name and the
 *   value is an integer or boolean that determines whether to grant or revoke
 *   the permission:
 *   @code
 *     array(
 *       'administer nodes' => 0,
 *       'access user profiles' => 1,
 *     )
 *   @endcode
 *   Existing permissions are not changed, unless specified in $permissions.
 *
 * @see og_user_role_grant_permissions()
 * @see og_user_role_revoke_permissions()
 */
function og_user_role_change_permissions($rid, array $permissions = array()) {
  // Grant new permissions for the role.
  $grant = array_filter($permissions);
  if (!empty($grant)) {
    og_user_role_grant_permissions($rid, array_keys($grant));
  }
  // Revoke permissions for the role.
  $revoke = array_diff_assoc($permissions, $grant);
  if (!empty($revoke)) {
    og_user_role_revoke_permissions($rid, array_keys($revoke));
  }
}

/**
 * Grant permissions to a user role.
 *
 * @param $rid
 *   The ID of a user role to alter.
 * @param $permissions
 *   A list of permission names to grant.
 *
 * @see user_role_change_permissions()
 * @see user_role_revoke_permissions()
 */
function og_user_role_grant_permissions($rid, array $permissions = array()) {
  // Grant new permissions for the role.
  foreach ($permissions as $name) {
    db_merge('og_role_permission')
      ->key(array(
        'rid' => $rid,
        'permission' => $name,
      ))
      ->execute();
  }

  // Clear the user access cache.
  drupal_static_reset('og_user_access');
  drupal_static_reset('og_user_role_permissions');
}

/**
 * Revoke permissions from a user role.
 *
 * @param $rid
 *   The ID of a user role to alter.
 * @param $permissions
 *   A list of permission names to revoke.
 *
 * @see user_role_change_permissions()
 * @see user_role_grant_permissions()
 */
function og_user_role_revoke_permissions($rid, array $permissions = array()) {
  // Revoke permissions for the role.
  db_delete('og_role_permission')
    ->condition('rid', $rid)
    ->condition('permission', $permissions, 'IN')
    ->execute();

  // Clear the user access cache.
  drupal_static_reset('og_user_access');
  drupal_static_reset('og_user_role_permissions');
}

function og_permissions_get() {
  $perms = &drupal_static(__FUNCTION__, array());
  if (!empty($perms)) {
    return $perms;
  }

  $perms = module_invoke_all('og_permission');
  return $perms;
}

/**
 * Get a private token used to protect links from spoofing - CSRF.
 */
function og_get_token($nid) {
  return drupal_get_token($nid);
}

/**
 * Check to see if a token value matches the specified node.
 */
function og_check_token($token, $seed) {
  return drupal_get_token($seed) == $token;
}

/**
 * Implement hook_og_user_operations().
 */
function og_og_user_operations($form = array(), $form_state = array()) {
  $nid = $form_state['nid'];
  $operations = array(
    'unblock' => array(
      'label' => t('Approve membership of the selected users'),
      'callback' => 'og_user_operations_approve',
    ),
    'deny' => array(
      'label' => t('Deny membership from the selected users'),
      'callback' => 'og_user_operations_deny',
    ),
    'block' => array(
      'label' => t('Block membership from the selected users'),
      'callback' => 'og_user_operations_block',
    ),
  );

  if (og_user_access($nid, 'administer group permissions')) {
    $roles = og_get_group_roles($nid);
    // Can't edit anonymous and authenticated role.
    unset($roles[OG_ANONYMOUS_ROLE]);
    unset($roles[OG_AUTHENTICATED_ROLE]);

    // Flip roles array, so we get the role name.
    $roles = array_flip($roles);

    $add_roles = array();
    foreach ($roles as $key => $value) {
      $add_roles['add_role-' . $key] = $value;
    }

    $remove_roles = array();
    foreach ($roles as $key => $value) {
      $remove_roles['remove_role-' . $key] = $value;
    }

    if (count($roles)) {
      $role_operations = array(
        t('Add a role to the selected users') => array(
          'label' => $add_roles,
        ),
        t('Remove a role from the selected users') => array(
          'label' => $remove_roles,
        ),
      );

      $operations += $role_operations;
    }
  }

  // If the form has been posted, we need to insert the proper data for
  // role editing if necessary.
  if (!empty($form_state['submitted'])) {
    $operation_rid = explode('-', $form_state['values']['operation']);
    $operation = $operation_rid[0];
    if ($operation == 'add_role' || $operation == 'remove_role') {
      $rid = $operation_rid[1];
      if (og_user_access($nid, 'administer group permissions')) {
        $operations[$form_state['values']['operation']] = array(
          'callback' => 'og_user_multiple_role_edit',
          'callback arguments' => array($operation, $rid),
        );
      }
      else {
        watchdog('security', 'Detected malicious attempt to alter protected user fields.', array(), WATCHDOG_WARNING);
        return;
      }
    }
  }

  return $operations;
}

/**
 * Callback function for admin mass approving users.
 */
function og_user_operations_approve($nid, $accounts) {
  $node = node_load($nid);
  // Intersect account with pending or blocked state users.
  $users = array_keys(og_get_group_users($nid, array(OG_STATE_PENDING, OG_STATE_BLOCKED)));
  $accounts = array_intersect($accounts, $users);
  $accounts = user_load_multiple($accounts);
  foreach ($accounts as $account) {
    $group = array(
      'value' => $nid,
      // Get the state of the group, and decide the user's state accordingly.
      'state' => OG_STATE_ACTIVE,
    );
    og_subscribe_user(array($group), $account);
  }
}

/**
 * Callback function for admin mass denying users.
 */
function og_user_operations_deny($nid, $accounts) {
  $node = node_load($nid);
  $accounts = user_load_multiple($accounts);

  foreach ($accounts as $account) {
    og_unsubscribe_user(array($nid), $account);
  }
}

/**
 * Callback function for admin mass approving users.
 */
function og_user_operations_block($nid, $accounts) {
  $node = node_load($nid);
  // Intersect account with pending or blocked state users.
  $users = array_keys(og_get_group_users($nid, array(OG_STATE_ACTIVE, OG_STATE_PENDING)));
  $accounts = array_intersect($accounts, $users);
  $accounts = user_load_multiple($accounts);
  foreach ($accounts as $account) {
    $group = array(
      'value' => $nid,
      // Get the state of the group, and decide the user's state accordingly.
      'state' => OG_STATE_BLOCKED,
    );
    og_subscribe_user(array($group), $account);
  }
}

/**
 * Callback function for admin mass adding/deleting a user role.
 */
function og_user_multiple_role_edit($nid, $accounts, $operation, $rid) {
  switch ($operation) {
    case 'add_role':
      $accounts = user_load_multiple($accounts);
      foreach ($accounts as $account) {
        og_users_roles_grant($nid, $account->uid, $rid);

      }
      break;
    case 'remove_role':
      $accounts = user_load_multiple($accounts);
      foreach ($accounts as $account) {
        og_users_roles_revoke($nid, $account->uid, $rid);
      }
      break;
  }
}