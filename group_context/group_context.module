<?php
// $Id:$

/**
 * @file
 * Associate theme to a group.
 */


/**
 * Implements hook_menu().
 */
function group_context_menu() {
  $items['admin/config/group/context'] = array(
    'title' => 'Group context',
    'description' => 'Group context detection and selection',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('group_context_configure_form'),
    'access arguments' => array('administer group'),
    'file' => 'group_context.admin.inc',
    'type' => MENU_LOCAL_TASK,
  );

  return $items;
}

/**
 * Implements hook_theme().
 */
function group_context_theme() {
  return array(
    'group_context_configure_form' => array(
      'render element' => 'form',
    ),
  );
}

/**
 * Save a list of language providers.
 *
 * @param $type
 *   The language negotiation type.
 * @param $language_providers
 *   An array of language provider ids.
 */
function group_context_negotiation_set($type, $group_context_providers) {
  // Save only the necessary fields.
  $provider_fields = array('callbacks', 'file', 'cache');

  $negotiation = array();
  $providers_weight = array();
  $defined_providers = group_context_negotiation_info();

  // Initialize the providers weight list.
  foreach ($group_context_providers as $id => $provider) {
    $providers_weight[$id] = group_context_provider_weight($provider);
  }

  // Order providers list by weight.
  asort($providers_weight);

  foreach ($providers_weight as $id => $weight) {
    if (isset($defined_providers[$id])) {
      $provider = $defined_providers[$id];

      $provider_data = array();
      foreach ($provider_fields as $field) {
        if (isset($provider[$field])) {
          $provider_data[$field] = $provider[$field];
        }
      }
      $negotiation[$id] = $provider_data;
    }
  }

  variable_set("group_context_negotiation_$type", $negotiation);
}


/**
 * Return the passed group context provider weight or a default value.
 *
 * @param $provider
 *   A group context provider data structure.
 *
 * @return
 *   A numeric weight.
 */
function group_context_provider_weight($provider) {
  $default = is_numeric($provider) ? $provider : 0;
  return isset($provider['weight']) && is_numeric($provider['weight']) ? $provider['weight'] : $default;
}




/**
 * Return all the defined group context providers.
 *
 * @return
 *   An array of group context providers.
 */
function group_context_negotiation_info() {
  $group_context_providers = &drupal_static(__FUNCTION__);

  if (!isset($group_context_providers)) {
    // Collect all the module-defined group_context negotiation providers.
    $group_context_providers = module_invoke_all('group_context_negotiation_info');

    // Let other modules alter the list of group_context providers.
    drupal_alter('group_context_negotiation_info', $group_context_providers);
  }

  // Assign default values.
  foreach ($group_context_providers as &$group_context_provider) {
    $group_context_provider += array(
      'menu' => TRUE,
      'menu path' => array(),
    );
  }

  return $group_context_providers;
}

/**
 * Implements hook_group_context_negotiation_info().
 */
function group_context_group_context_negotiation_info() {
  $providers = array();

  $providers['session'] = array(
    'name' => t('Session'),
    'description' => t("Use the group context that was detected in previous pages, as long as it matches the viewed one as-well."),
    'callback' => 'group_context_handler_session',
    'menu' => FALSE,
  );

  $providers['url'] = array(
    'name' => t('URL'),
    'description' => t("URL."),
    'callback' => 'group_context_handler_url',
    'menu' => FALSE,
  );

  $providers['node'] = array(
    'name' => t('Node'),
    'description' => t("Node."),
    'callback' => 'group_context_handler_node',
    'menu path' => array('node/%', 'node/%/edit'),
  );

  $providers['user-view'] = array(
    'name' => t('User view'),
    'description' => t("User view."),
    'callback' => 'group_context_handler_user_view',
    'menu path' => array('user/%'),
  );

  $providers['user-edit'] = array(
    'name' => t('User edit'),
    'description' => t("User edit."),
    'callback' => 'group_context_handler_user_edit',
    'menu path' => array('user/%/edit'),
  );

  return $providers;
}




/**
 * Implement hook_init().
 */
function group_context_init() {
  // group_context();
}


/**
 * Get all the context handlers.
 */
function group_get_context_handlers() {
  $handlers = module_invoke_all('group_context_handlers');

  // Assign default values.
  foreach ($handlers as &$handler) {
    $handler += array(
      'menu' => TRUE,
      'menu path' => array(),
      'priority' => FALSE,
    );
  }

  // Allow other modules to alter the handlers.
  drupal_alter('group_context_handlers', $handlers);

  return $handlers;
}

/**
 * Determine the best matching context of a viewed content.
 *
 * The context is determined by using handlers, and trying to find the best
 * matching context by giving a score to each returned group context. The score
 * is measured by the amount of times a single group was returned by different
 * handlers.
 * After accumilating all context results, we try to find if there is a matching
 * "priority" context. An example for a priority context is the "session"
 * handler; If we already presented a certain context to a user on the last page
 * we try to keep the same context if possible.
 * @see group_group_context_handlers().
 */
function group_context_determine_context() {
  $context = FALSE;

  $score = $priority = $gids = array();

  $item = menu_get_item();

  foreach (group_get_context_handlers() as $handler) {
    $invoke = FALSE;
    if ($handler['menu']) {
      if (in_array($item['path'], $handler['menu path'])) {
        $invoke = TRUE;
      }
    }
    else {
      $invoke = TRUE;
    }

    if ($invoke && ($return = call_user_func($handler['callback']))) {
      if ($handler['priority']) {
        $priority += $return;
      }
      else {
        // Keep score of the returning groups.
        foreach ($gids as $gid) {
          $score[$gid] = !empty($score[$gid]) ? $score[$gid] + 1 : 1;
        }

        $gids += $return;
      }
    }
  }
  if ($gids) {
    // Check if we have priority groups.
    if ($priority && ($priority_gids = array_intersect($gids, $priority))) {
      $context = group_load(reset($priority_gids));
    }
    else {
      // Get the group with the best score.
      $max = max($gids);
      $gid = array_search($max, $gids);
      $context = group_load($gid);
    }
  }

  return $context;
}


/**
 * Context handler; Get groups from user's session.
 */
function group_context_handler_session() {
  $context = array();

  if (!empty($_SESSION['group_context'])) {
    $context = drupal_map_assoc(array($_SESSION['group_context']));
  }

  return $context;
}

/**
 * Context handler; Get groups from URL.
 */
function group_context_handler_url() {
  $context = array();
  if ($gids = group_get_context_by_url()) {
    $context = $gids;
  }

  return $context;
}

/**
 * Context handler; Get groups from existing node.
 */
function group_context_handler_node() {
  return _group_context_handler_entity();
}

/**
 * Context handler; Get groups from user view.
 */
function group_context_handler_user_view() {
  global $user;
  return _group_context_handler_entity('user', $user);
}

/**
 * Context handler; Get groups from user edit.
 */
function group_context_handler_user_edit() {
  return _group_context_handler_entity('user');
}

/**
 * Helper function to get group context from an entity.
 *
 * @param $entity_type
 *   The entity type.
 * @param $entity
 *   Optional; The entity object.
 * @param $position
 *   Optional; The position that should be used in menu_get_object().
 */
function _group_context_handler_entity($entity_type = 'node', $entity = NULL, $position = 1) {
  $context = array();

  if (empty($entity)) {
    $entity = menu_get_object($entity_type, $position);
  }

  // Check if the entity is itself a group.
  list($id) = entity_extract_ids($entity_type, $entity);
  if ($group = group_get_group($entity_type, $id)) {
    $context = drupal_map_assoc(array($group->gid));
  }

  elseif ($gids = group_get_entity_groups($entity_type, $entity)) {
    $context = $gids;
  }

  return $context;
}


/**
 * Get or set group context using the menu system.
 *
 * @param $group
 *   Optional; The group entity to set as the context.
 * @param $account
 *   Optional; The user entity to determine context form.
 *
 * @return
 *   A group entity, or FALSE if no context was found.
 */
function group_context($group = NULL, $account = NULL) {
  global $user;
  $context = &drupal_static(__FUNCTION__, FALSE);

  if (!empty($group)) {
    $context = $group;
  }

  if (empty($context) && variable_get('group_context', TRUE)) {

    // Get context from context handlers.
    $context = group_context_determine_context();

    if ($user->uid && $context) {
      // Save the group ID in the authenticated user's session,
      $_SESSION['group_context'] = $context->gid;
    }
  }

  return $context;
}

/**
 * Add the group entity of the context to the Drupal javascript entity.
 *
 * @param $group
 *   A group entity.
 */
function group_context_add_js($group) {
  // Static variable to indicate if group was already added to javacript.
  $js = &drupal_static(__FUNCTION__, FALSE);
  if (empty($js)) {
    drupal_add_js(array('group' => array('group_context' => $group)), 'setting');
    $js = TRUE;
  }
}



/**
 * Implement hook_group_context_handlers()
 */
function group_group_context_handlers() {
  $items = array();

  $items['session'] = array(
    'callback' => 'group_context_handler_session',
    'menu' => FALSE,
    'priority' => TRUE,
  );

  $items['url'] = array(
    'callback' => 'group_context_handler_url',
    'menu' => FALSE,
  );

  $items['node'] = array(
    'callback' => 'group_context_handler_node',
    'menu path' => array('node/%', 'node/%/edit'),
  );

  $items['user_view'] = array(
    'callback' => 'group_context_handler_user_view',
    'menu path' => array('user/%'),
  );

  $items['user_edit'] = array(
    'callback' => 'group_context_handler_user_edit',
    'menu path' => array('user/%/edit'),
  );

  return $items;
}


/**
 * Implement hook_preprocess_html().
 *
 * HTML preprocess; Add context related templates and CSS.
 */
function group_context_preprocess_html(&$variables) {
  if ($group = group_context()) {
    // Add template suggestions.
    $variables['theme_hook_suggestions'][] = 'page__group_context';
    $variables['theme_hook_suggestions'][] = 'page__group_context__' . $group->gid;
    $variables['theme_hook_suggestions'][] = 'page__group_context__' . $group->entity_type;
    $variables['theme_hook_suggestions'][] = 'page__group_context__' . $group->entity_type . '_' . $group->etid;

    // Add CSS.
    $clean_html = drupal_html_class('group-context-' . $group->entity_type);
    $variables['classes_array'][] = 'group-context';
    $variables['classes_array'][] = 'group-context-' . $group->gid;
    $variables['classes_array'][] = $clean_html;
    $variables['classes_array'][] = $clean_html . '-' . $group->etid;

    // Add context to JS.
    group_context_add_js($group);
  }
}
